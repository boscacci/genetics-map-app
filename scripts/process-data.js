const fs = require('fs');
const path = require('path');
const dotenv = require('dotenv');
const Papa = require('papaparse');
const CryptoJS = require('crypto-js');

// Load .secret_env if present (optional in CI)
const envPath = path.resolve(__dirname, '../.secret_env');
if (fs.existsSync(envPath)) {
  dotenv.config({ path: envPath });
}

// Single secret name; optional .secret_env already loaded for local dev
const SECRET_KEY = process.env.REACT_APP_SECRET_KEY;
if (!SECRET_KEY) {
  throw new Error('Missing secret: set REACT_APP_SECRET_KEY as a GitHub secret or provide it in .secret_env');
}

// Read and parse CSV
const csvPath = path.resolve(__dirname, '../data.csv');
let csvContent;
if (fs.existsSync(csvPath)) {
  csvContent = fs.readFileSync(csvPath, 'utf8');
} else if (process.env.DATA_CSV_BASE64) {
  csvContent = Buffer.from(process.env.DATA_CSV_BASE64, 'base64').toString('utf8');
  console.log('Loaded CSV data from DATA_CSV_BASE64 environment variable.');
} else {
  throw new Error('No data.csv file found and DATA_CSV_BASE64 environment variable is not set.');
}
const { data, errors } = Papa.parse(csvContent, {
  header: true,
  dynamicTyping: true,
  skipEmptyLines: true,
});
if (errors.length > 0) {
  console.error('CSV parsing errors:', errors);
}

// Filter and clean data (similar to parseCSVString)
const cleanLanguageString = (languageString) => {
  if (!languageString) return '';
  return languageString
    .replace(/[.,;!?()\[\]{}"'`]/g, '')
    .replace(/\s+/g, ' ')
    .trim();
};
// Helper function to convert NaN to empty string
const cleanValue = (value) => {
  if (value === null || value === undefined || (typeof value === 'number' && Number.isNaN(value))) {
    return '';
  }
  return value;
};

const parsedData = (data).filter((item) => {
  return item.Latitude && item.Longitude &&
    !Number.isNaN(Number(item.Latitude)) && !Number.isNaN(Number(item.Longitude));
}).map((item) => {
  // Handle First Name field specifically
  let firstName = cleanValue(item.name_first);
  let lastName = cleanValue(item.name_last);
  
  // If First Name is empty/NaN, set to "Anonymous Contributor" and clear last name
  if (!firstName || firstName === '') {
    firstName = 'Anonymous Contributor';
    lastName = '';
    console.log(`Set anonymous contributor for: ${item.email || 'no email'}`);
  }
  
  return {
    ...item,
    name_first: firstName,
    name_last: lastName,
    email: cleanValue(item.email),
    phone_work: cleanValue(item.phone_work),
    work_website: cleanValue(item.work_website),
    work_institution: cleanValue(item.work_institution),
    work_address: cleanValue(item.work_address),
    language_spoken: cleanLanguageString(item.language_spoken),
    interpreter_services: typeof item.uses_interpreters === 'string' ? item.uses_interpreters : 'unknown',
    City: cleanValue(item.City),
    Country: cleanValue(item.Country),
  };
});

// Encrypt JSON string
const jsonString = JSON.stringify(parsedData);
const encrypted = CryptoJS.AES.encrypt(jsonString, SECRET_KEY).toString();

// Write to src/secureDataBlob.ts
const outputPath = path.resolve(__dirname, '../src/secureDataBlob.ts');
const output = `// This file is auto-generated by scripts/process-data.js\nexport const ENCRYPTED_SPECIALISTS_DATA = "${encrypted}";\n`;
fs.writeFileSync(outputPath, output, 'utf8');
console.log('Encrypted data written to src/secureDataBlob.ts');

// Hash injection for App.tsx is handled by hash-secret.js and the CI workflow